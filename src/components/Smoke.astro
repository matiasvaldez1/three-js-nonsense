<div id="smoke-bkg" class="smoke"></div>

<script>
  import * as THREE from "three";

  const reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)");

  if (!reducedMotion.matches) {
    const $bkg = document.getElementById("smoke-bkg");

    let delta = 0;
    const clock = new THREE.Clock();
    const interval = 1 / 30; // fps

    let animationFrameId: number = 0;

    let w = window.innerWidth;
    let h = window.screen.height + 200;

    // inicializar Three.js
    // 3 cosas básicas: escena, cámara, renderizador

    // escena 🖼️
    const scene = new THREE.Scene();

    // camara 📹
    // 75 -> ángulo de visión
    const camera = new THREE.PerspectiveCamera(75, w / h, 1, 1000);
    camera.position.z = 500;
    scene.add(camera);

    // ▶️ renderizador
    const renderer = new THREE.WebGLRenderer({
      antialias: false,
      alpha: true,
      powerPreference: "high-performance",
      precision: "lowp",
    });
    renderer.setSize(w, h);
    // color de fondo
    scene.background = new THREE.Color("#FFFFFF");

    $bkg?.appendChild(renderer.domElement);

    const smokeParticles: THREE.Mesh[] = [];

    const smokeTexture = new THREE.TextureLoader().load("/smoke.webp");
    const villagerTexture = new THREE.TextureLoader().load("/villager.jpg");

    // 1. geometria
    const smokeGeo = new THREE.PlaneGeometry(300, 300);
    const cubeFaceGeo = new THREE.BoxGeometry(500, 500);

    // 2. material
    const smokeMaterial = new THREE.MeshLambertMaterial({
      map: smokeTexture,
      transparent: true,
      opacity: 1,
    });

    const cubeFaceMaterial = new THREE.MeshLambertMaterial({
      map: villagerTexture,
      transparent: false,
      opacity: 1,
    });

    //light

    const light = new THREE.DirectionalLight(0xffffff, 0.3);

    light.position.set(0, 0, 1);

    scene.add(light);

    //mesh

    const villager = new THREE.Mesh(cubeFaceGeo, cubeFaceMaterial);
    villager.position.set(0, 0, 0);
    scene.add(villager);


    let isDragging = false;
    let isZKeyPressed = false;
    let isSpacebarPressed = false;

    function onKeyDown(event: { key: string }) {
      if (event.key === " ") {
        isSpacebarPressed = true;
      }
      if (event.key === "z" || event.key === "Z") {
        isZKeyPressed = true;
      }
    }

    function onKeyUp(event: { key: string }) {
      if (event.key === " ") {
        isSpacebarPressed = false;
      }
      if (event.key === "z" || event.key === "Z") {
        isZKeyPressed = false;
      }
    }

    function onMouseDown(event: any) {
      isDragging = true;
    }

    function onMouseMove(event: {
      movementY: number;
      movementX: number;
      clientX: number;
      clientY: number;
    }) {
      if (isDragging) {
        if (isSpacebarPressed) {
          villager.position.z -= event.movementY * 0.5;
        } else if (isZKeyPressed) {
          villager.rotation.x += event.movementY * 0.01;
          villager.rotation.y += event.movementX * 0.01;
        } else {
          const mouse = new THREE.Vector2();
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(villager);

          if (intersects.length > 0) {
            const intersectPoint = intersects[0].point;

            villager.position.x = intersectPoint.x;
            villager.position.y = intersectPoint.y;
          }
        }
      }
    }

    function onMouseUp(event: any) {
      isDragging = false;
    }

    // Add event listeners
    window.addEventListener("keydown", onKeyDown);
    window.addEventListener("keyup", onKeyUp);
    window.addEventListener("mousedown", onMouseDown);
    window.addEventListener("mousemove", onMouseMove);
    window.addEventListener("mouseup", onMouseUp);

    const NUM_OF_PARTICLES = 30;

    for (let p = 0; p < NUM_OF_PARTICLES; p++) {
      const particle = new THREE.Mesh(smokeGeo, smokeMaterial);
      particle.position.set(
        Math.random() * 500 - 250,
        Math.random() * 500 - 250,
        Math.random() * 1000 - 100
      );
      particle.rotation.z = Math.random() * 360;
      scene.add(particle);
      smokeParticles.push(particle);
    }

    function resize() {
      h = window.screen.height + 200;
      w = window.innerWidth;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }

    function animate() {
      animationFrameId = requestAnimationFrame(animate);
      delta += clock.getDelta();

      if (delta > interval) {
        let count = smokeParticles.length;
        while (count--) {
          smokeParticles[count].rotation.z += delta * 0.2;
        }

        renderer.render(scene, camera);

        delta = 0;
      }
    }

    animate();

    // se va a disparar continuamente mientras hace el resize
    window.addEventListener("resize", resize);
  }
</script>

<style>
  .smoke {
    position: fixed;
    top: 0;
    z-index: -10;
    width: 100%;
    opacity: 1;
  }
</style>
